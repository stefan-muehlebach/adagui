//
// In diesem File befinden sich alle Widgets, die im Zusammenhang mit adagui
// existieren. Aktuell sind dies:
//
// Container Widgets
// -----------------
//   Group
//   Panel
//   Drawer
//   Scroller   (Geplant)
//
// Leaf Widgets (GUI bezogen)
// --------------------------
//   Button
//   TextButton
//   IconButton
//   RadioButton
//   Checkbox
//   Slider     A.k.a. Scrollbar
//   PageButton
//   Label      Nur fuer kurze, einzeilige Texte
//   Text       (Geplant, wie Label aber fuer groessere Textmengen mit spez.
//              Ausrichtung, waehlbarer Schrift und ev. Scrollbalken)
//
// Leaf Widgets (Graphik bezogen)
// ------------------------------
//   Circle
//   Rectangle
//   Line       (Geplant)
//
//   Canvas     Ein ziemlicher Exot! die beiden oben aufgefuehrten
//              Graphikelemente stehen in KEINEM Zusammenhang zu diesem Typ.
//
package adagui

import (
    "fmt"
    "image"
    _ "image/color"
    _ "image/png"
    _ "log"
    "math"
    "os"
    "time"
    _ "mju.net/adatft"
    "mju.net/adagui/geom"
    "mju.net/adagui/touch"
    "mju.net/adagui/value"
    "mju.net/gg"
    "mju.net/utils"
    "github.com/golang/freetype/truetype"
    "golang.org/x/image/font/gofont/gobold"
    "golang.org/x/image/font/gofont/goregular"
    _ "golang.org/x/image/font/gofont/gomedium"
    "golang.org/x/image/draw"
    "golang.org/x/image/font"
)

// Versuch einer einheitlichen und schoenen Definition der Interface-Farben.
// Es gibt 3 Farbarten: 'Color', 'White', 'Gray' und 'Black' in jeweils zwei
// Auspraegungen: '' (normal) und 'Light'. Alle Farben sind zu 100% deckend,
// d.h. Alpha ist 0xff.
var (
    // Bestimmende Farbe: Tuerkis
    //Color         = utils.Color{0x16, 0xa0, 0x85, 0xff}
    //ColorLight    = utils.Color{0x1a, 0xbc, 0x9c, 0xff}

    // Bestimmende Farbe: Blau
    Color         = utils.Color{0x29, 0x80, 0xb9, 0xff}
    ColorLight    = utils.Color{0x34, 0x98, 0xdb, 0xff}

    // Bestimmende Farbe: Violett
    //Color         = utils.Color{0x8e, 0x44, 0xad, 0xff}
    //ColorLight    = utils.Color{0x9b, 0x59, 0xb6, 0xff}

    White         = utils.Color{0xbd, 0xc3, 0xc7, 0xff}
    WhiteLight    = utils.Color{0xec, 0xf0, 0xf1, 0xff}

    Gray          = utils.Color{0x7f, 0x8c, 0x8d, 0xff}
    GrayLight     = utils.Color{0x95, 0xa5, 0xa6, 0xff}

    Black         = utils.Color{0x2c, 0x3e, 0x50, 0xff}
    BlackLight    = utils.Color{0x34, 0x49, 0x5e, 0xff}
)

// Der Typ Border wird fuer die Bezeichnung der vier Bildschirmseiten oder
// Richtungen verwendet.
type Border int

const (
    Left Border = iota
    Top
    Right
    Bottom
)

// Mit dem Typ Orientation koennen horizontale Ausrichtungen gegenueber
// vertikalen abgegrenzt werden.
type Orientation int

const (
    Horizontal Orientation = iota
    Vertical
)

//-----------------------------------------------------------------------------

// Eine Group ist die einfachste Form eines Containers. Es dient bloss als
// logisches Sammelbecken fuer Widgets. Es hat keine weiteren Eigenschaften
// wie bspw. Farbe oder ein eigenes Koordinatensystem.
type Group struct {
    ContainerEmbed
}

func NewGroup() (*Group) {
    g := &Group{}
    g.Wrapper = g
    g.Init()
    return g
}

func (g *Group) Contains(pt geom.Point) (bool) {
    return true
}

//-----------------------------------------------------------------------------

// Ein Panel ist eine komplexere Variante eines Containers. Er kann eine
// Hintergrundfarbe haben und ordnet seine Kinder gem. ihren Koordinaten an. 
type Panel struct {
    ContainerEmbed
    FillColor utils.Color
    Clip bool
}

func NewPanel(w, h float64) (*Panel) {
    g := &Panel{}
    g.Wrapper = g
    g.Init()
    g.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    g.FillColor = Black
    g.Clip = false
    return g
}

func (g *Panel) Paint(gc *gg.Context) {
    //log.Printf("Panel.Paint()")
    g.Marks.UnmarkNeedsPaint()
    gc.Push()
    g.Recalc()
    gc.Multiply(gg.Matrix(g.Matrix))
    gc.SetFillColor(g.FillColor)
    gc.DrawRectangle(0.0, 0.0, g.Rect.Dx(), g.Rect.Dy())
    if g.Clip {
        gc.ClipPreserve()
    }
    gc.Fill()

    g.ContainerEmbed.Paint(gc)

    gc.ResetClip()
    gc.Pop()
}

//-----------------------------------------------------------------------------

// Button, TextButton und IconButton funktionieren alle ungefaehr nach dem
// gleichen Prinzip - mit dem Unterschied, dass bei Button als Inhalt bloss
// eine Farbe, bei TextButton eben Text und bei IconButton ein ganzes
// image.Image als Inhalt verwendet werden kann.
var (
    btnHeight          = 40.0
    btnInsetHorizontal = 30.0
    btnInsetVertical   = 10.0
    btnInset           =  5.0
    btnLineWidth       =  0.0
    btnRectRoundRad    =  6.0

    //btnFillColorLight   = utils.Color{0x1a, 0xbc, 0x9c, 0xff}
    //btnFillColor        = utils.Color{0x16, 0xa0, 0x85, 0xff}
    //btnStrokeColorLight = utils.Color{0xec, 0xf0, 0xf1, 0xff}
    //btnStrokeColor      = utils.Color{0xbc, 0xc3, 0xc7, 0xff}
    //btnTextColor        = btnStrokeColorLight
    //btnPushedColor      = utils.Color{0x48, 0xc8, 0xb1, 0xff}

    btnFnt, _          = truetype.Parse(gobold.TTF)
    btnFntSize         = 15.0
    btnFntFace         = truetype.NewFace(btnFnt,
            &truetype.Options{Size: btnFntSize})

    radBtnSize         = 20.0
    radBtnLineWidth    =  4.0
    radBtnDotSize      =  8.0

    chkBoxSize         = 20.0
    chkBoxRoundRectRad =  6.0
)

// Buttons sind neutrale Knoepfe, ohne spezifischen Inhalt, d.h. ohne Text
// oder Icons. Sie werden selten direkt verwendet, sondern dienen als
// generische Grundlage fuer die weiter unten definierten Text- oder Icon-
// Buttons.
type Button struct {
    LeafEmbed
    FillColor, StrokeColor utils.Color
    pushed bool
}

func NewButton(w, h float64) (*Button) {
    b := &Button{}
    b.Wrapper = b
    b.Init()
    b.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    b.FillColor   = Color
    b.StrokeColor = WhiteLight
    b.pushed = false
    return b
}

func (b *Button) Paint(gc *gg.Context) {
    //log.Printf("Button.Paint()")
    b.Marks.UnmarkNeedsPaint()
    gc.DrawRoundedRectangle(b.Rect.Min.X, b.Rect.Min.Y, b.Rect.Dx(),
            b.Rect.Dy(), btnRectRoundRad)
    if b.pushed {
        gc.SetFillColor(b.FillColor.Brighten())
        gc.SetStrokeColor(b.StrokeColor.Brighten())
    } else {
        gc.SetFillColor(b.FillColor)
        gc.SetStrokeColor(b.StrokeColor)
    }
    gc.SetLineWidth(btnLineWidth)
    gc.FillStroke()
}

func (b *Button) OnInputEvent(evt touch.Event) {
    //log.Printf("%T: %v", b, evt)
    switch evt.Type {
    case touch.TypePress, touch.TypeEnter:
        b.pushed = true
        b.Mark(MarkNeedsPaint)
    case touch.TypeRelease, touch.TypeLeave:
        b.pushed = false
        b.Mark(MarkNeedsPaint)
    }
    b.CallTouchFunc(b.Wrapper, evt)
}

// Ein TextButton verhaelt sich analog zum neutralen Button, stellt jedoch
// zusaetzlich Text dar und passt seine Groesse diesem Text an.
type TextButton struct {
    Button
    txt string
    FontFace font.Face
    TextColor utils.Color
}

func NewTextButton(txt string) (*TextButton) {
    b := &TextButton{}
    b.Wrapper = b
    b.Init()
    b.pushed = false
    b.txt = txt
    b.FontFace = btnFntFace
    b.FillColor = Color
    b.StrokeColor = WhiteLight
    b.TextColor = WhiteLight

    width := font.MeasureString(b.FontFace, txt)
    w := float64(width)/64.0 + 2.0*btnInsetHorizontal
    h := float64(btnHeight)
    b.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    return b
}

func (b *TextButton) Paint(gc *gg.Context) {
    //log.Printf("TextButton.Paint()")
    b.Button.Paint(gc)
    gc.SetFontFace(b.FontFace)
    gc.SetStrokeColor(b.TextColor)
    gc.DrawStringAnchored(b.txt, b.Rect.Min.X+0.5*b.Rect.Dx(),
                b.Rect.Min.Y+0.5*b.Rect.Dy(), 0.5, 0.5)
}

// Der IconButton stellt ein kleines Bild dar, welches als PNG-Datei beim
// Erstellen des Buttons angegeben wird. Die Groesse des Buttons passt sich
// der Groess der Bilddatei an.
type IconButton struct {
    Button
    img image.Image
}

func NewIconButton(imgFile string) (*IconButton) {
    b := &IconButton{}
    b.Wrapper = b
    b.Init()
    b.pushed = false
    b.img, _ = gg.LoadPNG(imgFile)
    w := float64(b.img.Bounds().Dx()) + 2*btnInset
    h := float64(b.img.Bounds().Dy()) + 2*btnInset
    b.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    b.FillColor = Color
    b.StrokeColor = WhiteLight
    return b
}

func (b *IconButton) Paint(gc *gg.Context) {
    //log.Printf("IconButton.Paint()")
    b.Button.Paint(gc)
    gc.DrawImage(b.img, int(b.Rect.Min.X+btnInset), int(b.Rect.Min.Y+btnInset))
}

// Der RadioButton ist insofern ein Spezialfall, als er erstens zwei Zustaende
// haben kann (aktiv und nicht aktiv) und moeglicherweise einer Gruppe von
// RadioButtons angehoert, von denen nur einer aktiviert sein kann.
type RadioButton struct {
    Button
    checked bool
}

func NewRadioButton() (*RadioButton) {
    b := &RadioButton{}
    b.Wrapper = b
    b.Init()
    b.Rect = geom.Rectangle{Max: geom.Point{radBtnSize, radBtnSize}}
    b.FillColor   = Color
    b.StrokeColor = WhiteLight
    return b
}

func (b *RadioButton) Paint(gc *gg.Context) {
    //log.Printf("RadioButton.Paint()")
    b.Marks.UnmarkNeedsPaint()
    mp := b.Rect.Center()
    gc.DrawCircle(mp.X, mp.Y, radBtnSize/2.0)
    if b.pushed {
        gc.SetStrokeColor(b.StrokeColor.Brighten())
        gc.SetFillColor(b.FillColor.Brighten())
    } else {
        gc.SetStrokeColor(b.StrokeColor)
        gc.SetFillColor(b.FillColor)
    }
    gc.SetLineWidth(btnLineWidth)
    gc.FillStroke()
    if b.checked {
        gc.DrawCircle(mp.X, mp.Y, radBtnDotSize/2.0)
	gc.SetFillColor(b.StrokeColor)
	gc.Fill()
    }
}

func (b *RadioButton) OnInputEvent(evt touch.Event) {
    b.Button.OnInputEvent(evt)
    if evt.Type == touch.TypeTap {
        b.checked = !b.checked
    }
}

// Checkboxen verhalten sich sehr aehnlich zu RadioButtons, sind jeoch eigen-
// staendig und nicht Teil einer Gruppe.
type Checkbox struct {
    Button
    checked bool
}

func NewCheckbox() (*Checkbox) {
    c := &Checkbox{}
    c.Wrapper = c
    c.Init()
    c.Rect = geom.Rectangle{Max: geom.Point{chkBoxSize, chkBoxSize}}
    c.FillColor   = Color
    c.StrokeColor = WhiteLight
    return c
}

func (c *Checkbox) Paint(gc *gg.Context) {
    c.Marks.UnmarkNeedsPaint()
    gc.DrawRoundedRectangle(c.Rect.Min.X, c.Rect.Min.Y,
            c.Rect.Dx(), c.Rect.Dy(), chkBoxRoundRectRad)
    if c.pushed {
        gc.SetStrokeColor(c.StrokeColor.Brighten())
        gc.SetFillColor(c.FillColor.Brighten())
    } else {
        gc.SetStrokeColor(c.StrokeColor)
        gc.SetFillColor(c.FillColor)
    }
    gc.SetLineWidth(btnLineWidth)
    gc.FillStroke()
    if c.checked {
        gc.SetLineWidth(3.0)
        gc.SetStrokeColor(c.StrokeColor)
        gc.MoveTo(c.Rect.Min.X+5, c.Rect.Min.Y+10)
        gc.LineTo(c.Rect.Min.X+9, c.Rect.Min.Y+15)
        gc.LineTo(c.Rect.Max.X-5, c.Rect.Min.Y+6)
        gc.Stroke()
    }
}

func (c *Checkbox) OnInputEvent(evt touch.Event) {
    c.Button.OnInputEvent(evt)
    if evt.Type == touch.TypeTap {
        c.checked = !c.checked
    }
}

//-----------------------------------------------------------------------------

// Mit Slider kann man einen Schieberegler beliebiger Laenge horizontal oder
// vertikal im GUI positionieren. Als Werte sind aktuell nur Fliesskommazahlen
// vorgesehen.
var (
    sldWidth       = 16.0
    sldFillColor   = White
    sldCorner      = []geom.Point{
            geom.Point{0.0, sldWidth},
            geom.Point{sldWidth, 0.0},
    }
    sldExtent      = []geom.Point{
            geom.Point{1.0, 0.0},
            geom.Point{0.0, 1.0},
    }
    sldCtrlColor   = Color
    sldCtrlLen     = 2.0 * sldWidth
    sldCtrlSize    = []geom.Point{ 
            geom.Point{sldCtrlLen, sldWidth},
            geom.Point{sldWidth, sldCtrlLen},
    }
    sldLineWidth       = sldWidth
    sldActiveLineWidth = 4.0
    sldFnt, _          = truetype.Parse(goregular.TTF)
    sldFntSize         = 12.0
    sldFntFace         = truetype.NewFace(sldFnt,
            &truetype.Options{Size: sldFntSize})
    sldFntColor        = WhiteLight
    sldActiveFntColor  = WhiteLight
)

type Slider struct {
    LeafEmbed
    ValueEmbed
    orient Orientation
    minValue, maxValue, stepSize, value, oldValue float64
    len func() (float64)
    active bool
    ShowValues bool
}

func NewSlider(len float64, orient Orientation) (*Slider) {
    s := &Slider{}
    s.Wrapper = s
    s.Init()
    s.orient = orient
    s.Rect = geom.Rectangle{Max: sldExtent[orient].Mul(len).Add(sldCorner[orient])}
    s.minValue = 0.0
    s.maxValue = 1.0
    s.stepSize = 0.1
    s.value    = 0.0
    s.oldValue = 0.0
    if orient == Horizontal {
        s.len = s.Rect.Dx
    } else {
        s.len = s.Rect.Dy
    }
    s.active = false
    s.ShowValues = true
    return s
}

func (s *Slider) Paint(gc *gg.Context) {
    var f float64

    //log.Printf("Slider.Paint()")
    s.Marks.UnmarkNeedsPaint()
    gc.DrawRoundedRectangle(s.Rect.Min.X, s.Rect.Min.Y,
            s.Rect.Dx(), s.Rect.Dy(), sldWidth/2.0)
    gc.SetFillColor(sldFillColor)
    gc.Fill()

    if s.active && s.ShowValues {
        pt0 := s.Rect.Min.Add(sldCtrlSize[s.orient].Div(2.0))
        pt1 := s.Rect.Max.Sub(sldCtrlSize[s.orient].Div(2.0))
        lbl0 := fmt.Sprintf("%.1f", s.minValue)
        lbl1 := fmt.Sprintf("%.1f", s.maxValue)
        gc.SetFontFace(sldFntFace)
        gc.SetStrokeColor(sldActiveFntColor)
        gc.DrawStringAnchored(lbl0, pt0.X, pt0.Y, 0.5, 0.5)
        gc.DrawStringAnchored(lbl1, pt1.X, pt1.Y, 0.5, 0.5)
    }

    if s.orient == Horizontal {
        f = s.Factor()
    } else {
        f = 1.0 - s.Factor()
    }
    pt := s.Rect.Min.Add(sldExtent[s.orient].Mul(f*(s.len()-sldCtrlLen)))
    gc.DrawRoundedRectangle(pt.X, pt.Y, sldCtrlSize[s.orient].X,
            sldCtrlSize[s.orient].Y, sldWidth/2.0)
    gc.SetFillColor(sldCtrlColor)
    gc.SetStrokeColor(sldCtrlColor)
    gc.SetLineWidth(sldActiveLineWidth)
    gc.FillStroke()

    if s.active && s.ShowValues {
        pt2 := pt.Add(sldCtrlSize[s.orient].Div(2.0))
        lbl2 := fmt.Sprintf("%.1f", s.value)
        gc.SetStrokeColor(sldActiveFntColor)
        gc.DrawStringAnchored(lbl2, pt2.X, pt2.Y, 0.5, 0.5)
    }
}

func (s *Slider) SetRange(min, max, step float64) {
    s.minValue = min
    s.maxValue = max
    s.stepSize = step
}

func (s *Slider) Range() (float64, float64, float64) {
    return s.minValue, s.maxValue, s.stepSize
}

func (s *Slider) SetValue(v float64) {
    v = math.Round(v/s.stepSize)*s.stepSize
    if v > s.maxValue { v = s.maxValue }
    if v < s.minValue { v = s.minValue }
    if v != s.value {
        evt := value.Event{value.TypeChanging, s.value, v}
        s.value = v
        s.CallValueFunc(s.Wrapper, evt)
        s.Mark(MarkNeedsPaint)
    }
}

func (s *Slider) Value() (float64) {
    return s.value
}

func (s *Slider) SetFactor(f float64) {
    if f > 1.0 { f = 1.0 }
    if f < 0.0 { f = 0.0 }
    v := (1.0-f)*s.minValue + f*s.maxValue
    s.SetValue(v)
}

func (s *Slider) Factor() (float64) {
    return (s.value-s.minValue)/(s.maxValue-s.minValue)
}

func (s *Slider) OnInputEvent(evt touch.Event) {
    //log.Printf("%T: %v", s, evt)
    switch evt.Type {
    case touch.TypePress:
        s.active = true
        s.oldValue = s.value
        s.Mark(MarkNeedsPaint)
    case touch.TypeRelease:
        s.active = false
        evt := value.Event{value.TypeChanged, s.oldValue, s.value}
        s.CallValueFunc(s.Wrapper, evt)
        s.Mark(MarkNeedsPaint)
    case touch.TypeDrag:
        r := s.Rect.Inset(sldCtrlLen/2.0, sldCtrlLen/2.0)
        fx, fy := r.PosRel(evt.Pos)
        v := 0.0
        if s.orient == Horizontal {
            v = fx
        } else {
            v = 1.0 - fy
        }
        s.SetFactor(v)
    }
}

//----------------------------------------------------------------------------

// Schoene Kreise fuer Spiele oder was auch immer lassen sich mit diesem
// Widget-Typ auf den Schirm zaubern.
type Circle struct {
    LeafEmbed
    StrokeColor, FillColor utils.Color
    LineWidth float64
    radius float64
}

func NewCircle(r float64) (*Circle) {
    c := &Circle{}
    c.Wrapper = c
    c.Init()
    c.Rect = geom.Rectangle{Max: geom.Point{2*r, 2*r}}
    c.StrokeColor = utils.White
    c.FillColor= utils.Black
    c.LineWidth = 3.0
    c.radius = r
    return c
}

func (c *Circle) Paint(gc *gg.Context) {
    //log.Printf("Circle.Paint()")
    c.Marks.UnmarkNeedsPaint()
    gc.Push()
    c.Recalc()
    gc.Multiply(gg.Matrix(c.Matrix))
    mx, my := c.Rect.Center().AsCoord()
    gc.DrawCircle(mx, my, c.radius)
    gc.SetLineWidth(c.LineWidth)
    gc.SetFillColor(c.FillColor)
    gc.SetStrokeColor(c.StrokeColor)
    gc.FillStroke()
    gc.Pop()
}

func (c *Circle) Contains(pt geom.Point) (bool) {
    if !c.Embed.Contains(pt) {
        return false
    }
    return c.Rect.Center().Distance(pt) <= c.radius
}

func (c *Circle) Pos() (geom.Point) {
    return c.Rect.Center()
}

func (c *Circle) SetPos(p geom.Point) {
    c.Embed.SetPos(p.Sub(geom.Point{c.radius, c.radius}))
}

func (c *Circle) Radius() (float64) {
    return c.radius
}

func (c *Circle) SetRadius(r float64) {
    c.radius = r
    mp := c.Rect.Center()
    dp := geom.Point{r, r}
    c.Rect = geom.Rectangle{mp.Sub(dp), mp.Add(dp)}
}

//----------------------------------------------------------------------------

// Und wo es Kreise gibt, da sind auch die Rechtecke nicht weit.
type Rectangle struct {
    LeafEmbed
    StrokeColor, FillColor utils.Color
    LineWidth float64
}

func NewRectangle(w, h float64) (*Rectangle) {
    r := &Rectangle{}
    r.Wrapper = r
    r.Init()
    r.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    r.StrokeColor = utils.White
    r.FillColor= utils.Black
    r.LineWidth = 3.0
    return r
}

func (r *Rectangle) Paint(gc *gg.Context) {
    //log.Printf("Rectangle.Paint()")
    r.Marks.UnmarkNeedsPaint()
    gc.Push()
    r.Recalc()
    gc.Multiply(gg.Matrix(r.Matrix))
    gc.DrawRectangle(r.Rect.AsCoord())
    gc.SetLineWidth(r.LineWidth)
    gc.SetFillColor(r.FillColor)
    gc.SetStrokeColor(r.StrokeColor)
    gc.FillStroke()
    gc.Pop()
}

// Wir wollen es wissen und machen einen auf Game-Entwickler
type Sprite struct {
    LeafEmbed
    imgList []image.Image
    curImg int
    ticker *time.Ticker
}

func NewSprite(imgFiles ...string) (*Sprite) {
    s := &Sprite{}
    s.Wrapper = s
    s.Init()
    s.imgList = make([]image.Image, 0)
    s.curImg = 0
    s.AddImages(imgFiles...)
    pt := geom.NewPointIMG(s.imgList[0].Bounds().Size())
    s.Rect = geom.Rectangle{Max: pt}
    return s
}

func (s *Sprite) AddImages(imgFiles ...string) {
    for _, fileName := range imgFiles {
        fh, err := os.Open(fileName)
        utils.Check(err)
        img, _, err := image.Decode(fh)
        utils.Check(err)
        s.imgList = append(s.imgList, img)
        fh.Close()
    }
}

func (s *Sprite) Paint(gc *gg.Context) {
    s.Marks.UnmarkNeedsPaint()
    gc.Push()
    s.Recalc()
    gc.Multiply(gg.Matrix(s.Matrix))
    gc.DrawImage(s.imgList[s.curImg], int(s.Rect.Min.X), int(s.Rect.Min.Y))
    gc.Pop()
}

func (s *Sprite) StartAnim(dt time.Duration) {
    s.ticker = time.NewTicker(dt)
    go func() {
        for {
            <- s.ticker.C
            s.curImg = (s.curImg + 1) % len(s.imgList)
            s.Mark(MarkNeedsPaint)
            s.Win.Repaint()
        }
    }()
}

func (s *Sprite) StopAnim() {
    s.ticker.Stop()
}

// Unter einem Label verstehen wird einfach eine Konserve fuer Text. Kurzen
// Text! Fuer die Darstellung von groesseren Textmengen, bitte Widget Text
// beruecksichtigen.
type AlignType int

const (
    AlignLeft AlignType = (1 << 0)
    AlignCenter         = (1 << 1)
    AlignRight          = (1 << 2)
    AlignTop            = (1 << 3)
    AlignMiddle         = (1 << 4)
    AlignBottom         = (1 << 5)
)

var (
    lblTextColor = White
    lblFont, _   = truetype.Parse(goregular.TTF)
    lblFontSize  = 13.0
    lblFontFace  = truetype.NewFace(lblFont,
            &truetype.Options{Size: lblFontSize})
)

type Label struct {
    LeafEmbed
    Text string
    TextColor utils.Color
    FontFace font.Face
    Align AlignType
}

func NewLabel(txt string) (*Label) {
    l := &Label{}
    l.Wrapper = l
    l.Init()
    l.Text      = txt
    l.TextColor = WhiteLight
    l.FontFace  = lblFontFace
    l.Align     = AlignLeft | AlignMiddle
    l.Rect      = geom.Rectangle{Max: geom.Point{20, 20}}
    return l
}

func (l *Label) Paint(gc *gg.Context) {
    var pt geom.Point
    var ax, ay float64

    l.Marks.UnmarkNeedsPaint()
    switch {
    case l.Align & AlignLeft != 0:
        pt.X = l.Rect.Min.X
        ax = 0.0
    case l.Align & AlignCenter != 0:
        pt.X = (l.Rect.Min.X+l.Rect.Max.X)/2.0
        ax = 0.5
    case l.Align & AlignRight != 0:
        pt.X = l.Rect.Max.X
        ax = 1.0
    }
    switch {
    case l.Align & AlignBottom != 0:
        pt.Y = l.Rect.Max.Y
        ay = 0.0
    case l.Align & AlignMiddle != 0:
        pt.Y = (l.Rect.Min.Y+l.Rect.Max.Y)/2.0
        ay = 0.5
    case l.Align & AlignTop != 0:
        pt.Y = l.Rect.Min.Y
        ay = 1.0
    }
    gc.SetFontFace(l.FontFace)
    gc.SetStrokeColor(l.TextColor)
    gc.DrawStringAnchored(l.Text, pt.X, pt.Y, ax, ay)
}















/*
var (
    lblLineWidth       =  2.0
    lblInsetHorizontal = 15.0
    lblInsetVertical   = 10.0
    lblStrokeColor     = utils.Color{0, 0, 0, 0}
    lblFillColor       = utils.Color{0, 0, 0, 0}
    lblFnt, _          = truetype.Parse(goregular.TTF)
    lblFntSize         = 13.0
    lblFntFace         = truetype.NewFace(lblFnt,
            &truetype.Options{Size: lblFntSize})
    lblTextColor       = utils.Color{255, 255, 255, 255}
    lblLineSpacing     = 1.8
)

type Label struct {
    LeafEmbed
    FillColor, StrokeColor, TextColor utils.Color
    txt string
}

func NewLabel(txt string, width float64) (*Label) {
    l := &Label{}
    l.Wrapper = l
    l.Init()
    l.txt = txt
    l.FillColor   = lblFillColor
    l.StrokeColor = lblStrokeColor
    l.TextColor   = lblTextColor
    l.Rect = geom.Rectangle{Max: geom.Point{width, radBtnSize}}
    return l
}

func (l *Label) Paint(gc *gg.Context) {
    //log.Printf("Label.Paint()")
    l.Marks.UnmarkNeedsPaint()
    gc.SetFontFace(lblFntFace)
    //gc.SetStrokeColor(l.StrokeColor)
    //gc.SetLineWidth(lblLineWidth)
    //gc.SetFillColor(l.FillColor)
    //gc.DrawRectangle(l.Rect.AsCoord())
    //gc.FillStroke()
    //gc.SetStrokeColor(l.TextColor)
    //gc.DrawStringAnchored(l.txt, l.Rect.Min.X+0.5*l.Rect.Dx(),
    //        l.Rect.Min.Y+0.5*l.Rect.Dy(), 0.5, 0.5)
    gc.DrawStringWrapped(l.txt, l.Rect.Min.X, (l.Rect.Min.Y+l.Rect.Max.Y)/2.0,
             0, 0.5, l.Rect.Dx(), lblLineSpacing, gg.AlignLeft)
}

func (l *Label) SetText(txt string) {
    l.txt = txt
}

func (l *Label) Text() (string) {
    return l.txt
}
*/

/*
func (l *Label) updateRect() {
    width := font.MeasureString(lblFntFace, l.txt)
    height := lblFntFace.Metrics().Ascent
    w := float64(width)/64.0  + 2.0*lblInsetHorizontal
    h := float64(height)/64.0 + 2.0*lblInsetVertical
    l.Rect.Max = l.Rect.Min.Add(geom.Point{w, h})
}
*/

//-----------------------------------------------------------------------------

var (
    canvBackColor = utils.Color{12, 14, 12, 255}
    canvPenColor  = utils.Color{255,255,255,255}
    canvPenAlpha  = uint8(255)
    canvPenSize   = 5.0
)

type Canvas struct {
    LeafEmbed
    BackColor, PenColor utils.Color
    PenAlpha uint8
    PenSize float64
    gc *gg.Context
}

func NewCanvas(w, h float64) (*Canvas) {
    c := &Canvas{}
    c.Wrapper = c
    c.Init()
    c.Rect = geom.Rectangle{Max: geom.Point{w, h}}
    c.BackColor = canvBackColor
    c.PenColor  = canvPenColor
    c.PenAlpha  = canvPenAlpha
    c.PenSize   = canvPenSize
    c.gc = gg.NewContext(int(w), int(h))
    c.gc.SetFillColor(c.BackColor)
    c.gc.Clear()
    c.gc.SetStrokeColor(c.PenColor)
    return c
}

func (c *Canvas) Paint(gc *gg.Context) {
    //log.Printf("Canvas.Paint()")
    dst := gc.Image().(*image.RGBA)
    src := c.gc.Image().(*image.RGBA)
    c.Marks.UnmarkNeedsPaint()
    draw.Copy(dst, c.Rect.Min.Int(), src, src.Bounds(), draw.Src, nil)
}

func (c *Canvas) OnInputEvent(evt touch.Event) {
    switch evt.Type {
    case touch.TypeDrag:
        pos := evt.Pos.Sub(c.Rect.Min)
	c.PenColor.A = c.PenAlpha
	c.gc.SetFillColor(c.PenColor)
	c.gc.DrawPoint(pos.X, pos.Y, c.PenSize)
	c.gc.Fill()
	c.Mark(MarkNeedsPaint)
    }
}

// ----------------------------------------------------------------------------

// GUI daten sowohl fuer PageButton als auch Drawer
var (
    flapWidth            = 22.0
    flapHeight           = 60.0
    flapInset            =  9.0
    flapRectRad          =  6.0
    flapFillColor        = utils.Color{255, 255, 255, 100}
    flapPushedFillColor  = utils.White
    flapArrowColor       = utils.Color{255, 255, 255, 100}
    flapPushedArrowColor = utils.White
    flapArrowWidth       =  8.0
    flapRect = []geom.Rectangle{
	    geom.Rectangle{Max: geom.Point{flapWidth, flapHeight}},
	    geom.Rectangle{Max: geom.Point{flapHeight, flapWidth}},
	    geom.Rectangle{Max: geom.Point{flapWidth, flapHeight}},
	    geom.Rectangle{Max: geom.Point{flapHeight, flapWidth}},
    }
    flapRectInsets = [][]geom.Point{
        {
            geom.Point{-flapRectRad, 0.0},
            geom.Point{},
        },
        {
            geom.Point{0.0, -flapRectRad},
            geom.Point{},
        },
        {
            geom.Point{},
            geom.Point{flapRectRad, 0.0},
        },
        {
            geom.Point{},
            geom.Point{0.0, flapRectRad},
        },
    }
    pgBtnFillColor = utils.Color{255, 255, 255,  63}
    drwFillColor   = utils.Color{255, 255, 255, 100}
)

func DrawArrow(gc *gg.Context, dst geom.Rectangle, pos Border) {
    switch pos {
    case Left:
        gc.MoveTo(dst.Max.X, dst.Min.Y)
        gc.LineTo(dst.Min.X, (dst.Min.Y+dst.Max.Y)/2.0)
        gc.LineTo(dst.Max.X, dst.Max.Y)
    case Top:
        gc.MoveTo(dst.Min.X, dst.Max.Y)
        gc.LineTo((dst.Min.X+dst.Max.X)/2.0, dst.Min.Y)
        gc.LineTo(dst.Max.X, dst.Max.Y)
    case Right:
        gc.MoveTo(dst.Min.X, dst.Min.Y)
        gc.LineTo(dst.Max.X, (dst.Min.Y+dst.Max.Y)/2.0)
        gc.LineTo(dst.Min.X, dst.Max.Y)
    case Bottom:
        gc.MoveTo(dst.Min.X, dst.Min.Y)
        gc.LineTo((dst.Min.X+dst.Max.X)/2.0, dst.Max.Y)
        gc.LineTo(dst.Max.X, dst.Min.Y)
    }
}

//-----------------------------------------------------------------------------

// PageButton dienen vorallem fuer den Wechsel zwischen den Windows, koennen
// aber auch fuer anderes verwendet werden.
type PageButton struct {
    LeafEmbed
    pos Border
    pushed bool
    ExtRect geom.Rectangle
}

func NewPageButton(pos Border) (*PageButton) {
    b := &PageButton{}
    b.Wrapper = b
    b.Init()
    b.pos = pos
    b.pushed = false
    b.Rect = flapRect[b.pos]
    b.SetPos(geom.Point{})
    return b
}

func (b *PageButton) SetPos(pt geom.Point) {
    switch b.pos {
    case Left:
        pt.X = 0.0
        pt.Y -= flapHeight/2.0
    case Top:
        pt.X -= flapHeight/2.0
        pt.Y = 0.0
    case Right:
        pt.X = 298.0
        pt.Y -= flapHeight/2.0
    case Bottom:
        pt.X -= flapHeight/2.0
        pt.Y = 218.0
    }
    b.Wrappee().SetPos(pt)

    b.ExtRect = b.Rect.Sub(b.Rect.Min)
    b.ExtRect = geom.Rectangle{
        b.ExtRect.Min.Add(flapRectInsets[b.pos][0]),
        b.ExtRect.Max.Add(flapRectInsets[b.pos][1]),
    }
}

func (b *PageButton) Paint(gc *gg.Context) {
    //log.Printf("PageButton.Paint()")
    b.Marks.UnmarkNeedsPaint()

    gc.Push()
    gc.Translate(b.Rect.Min.AsCoord())
    gc.DrawRoundedRectangle(b.ExtRect.Min.X, b.ExtRect.Min.Y,
            b.ExtRect.Dx(), b.ExtRect.Dy(), flapRectRad)
    gc.SetFillColor(pgBtnFillColor)
    gc.Fill()

    if b.pushed {
        gc.SetStrokeColor(flapPushedArrowColor)
    } else {
        gc.SetStrokeColor(flapArrowColor)
    }
    gc.SetLineWidth(flapArrowWidth)
    DrawArrow(gc, b.ExtRect.Inset(flapInset, flapInset), b.pos)
    gc.Stroke()
    gc.Pop()
}

func (b *PageButton) OnInputEvent(evt touch.Event) {
    //log.Printf("%T: %v", b, evt)
    switch evt.Type {
    case touch.TypePress, touch.TypeEnter:
        b.pushed = true
        b.Mark(MarkNeedsPaint)
    case touch.TypeLeave:
        b.pushed = false
        b.Mark(MarkNeedsPaint)
    case touch.TypeRelease:
        b.pushed = false
        b.Mark(MarkNeedsPaint)
    }
    b.CallTouchFunc(b.Wrapper, evt)
}

// Der Drawer (engl. Schublade) kann eine Reihe von weiteren Widgets aufnehmen
// und laesst sich bei Nichtbedarf am Rand des Bildschirms auf ein kleines
// Icon zusammenklappen. Eine Antwort auf den beschraenkten Platz des Adafruit
// TFT-Bildschirm.
var (
    drwSizeChange = [][]geom.Point{
        {
            geom.Point{},
            geom.Point{100.0, 0.0},
        },
	    {
            geom.Point{},
            geom.Point{0.0, 100.0},
        },
        {
            geom.Point{-100.0, 0.0},
            geom.Point{},
        },
        {
            geom.Point{0.0, -100.0},
            geom.Point{},
        },
    }
)

type Drawer struct {
    ContainerEmbed
    pos Border
    FillColor utils.Color
    pushed bool
    handle geom.Rectangle
    isOpen bool
    ExtRect geom.Rectangle
}

func NewDrawer(pos Border) (*Drawer) {
    d := &Drawer{}
    d.Wrapper = d
    d.Init()
    d.pos = pos
    d.FillColor = flapFillColor
    d.pushed = false
    d.isOpen = false
    d.Rect = flapRect[d.pos]
    return d
}

func (d *Drawer) SetPos(pt geom.Point) {
    switch d.pos {
    case Left:
        pt.X = 0.0
    case Top:
        pt.Y = 0.0
    case Right:
        pt.X = 298.0
    case Bottom:
        pt.Y = 218.0
    }
    d.Wrappee().SetPos(pt)

    d.ExtRect = d.Rect.Sub(d.Rect.Min)
    d.ExtRect = geom.Rectangle{
        d.ExtRect.Min.Add(flapRectInsets[d.pos][0]),
        d.ExtRect.Max.Add(flapRectInsets[d.pos][1]),
    }
}

func (d *Drawer) Paint(gc *gg.Context) {
    //log.Printf("Drawer.Paint()")
    d.Marks.UnmarkNeedsPaint()

    gc.Push()
    gc.Translate(d.Rect.Min.AsCoord())
    gc.DrawRoundedRectangle(d.ExtRect.Min.X, d.ExtRect.Min.Y,
            d.ExtRect.Dx(), d.ExtRect.Dy(), flapRectRad)
    //log.Printf("Drawer.Paint():")
    if d.pushed {
        gc.SetFillColor(flapPushedFillColor)
    } else {
        gc.SetFillColor(d.FillColor)
    }
    gc.Fill()

    gc.SetStrokeColor(flapArrowColor)
    gc.SetLineWidth(flapArrowWidth)
    DrawArrow(gc, d.ExtRect.Inset(flapInset, flapInset), (d.pos+2)%4)
    gc.Stroke()

    gc.DrawRectangle(d.ExtRect.AsCoord())
    gc.Clip()
    //d.ContainerEmbed.Paint(gc)
    gc.ResetClip()
    gc.Pop()
}

func (d *Drawer) OnInputEvent(evt touch.Event) {
    //log.Printf("Drawer.OnInputEvent(): %T, %v", d, evt)
    switch evt.Type {
    case touch.TypePress, touch.TypeEnter:
        d.pushed = true
        d.Mark(MarkNeedsPaint)
    case touch.TypeLeave, touch.TypeRelease:
        d.pushed = false
        d.Mark(MarkNeedsPaint)
    case touch.TypeTap:
        if d.isOpen {
            d.Close()
        } else {
            d.Open()
        }
    }
}

func (d *Drawer) IsOpen() (bool) {
    return d.isOpen
}

func (d *Drawer) Open() {
    if d.isOpen {
        return
    }
    d.isOpen = true
    d.Rect.Min = d.Rect.Min.Add(drwSizeChange[d.pos][0])
    d.Rect.Max = d.Rect.Max.Add(drwSizeChange[d.pos][1])
    d.Mark(MarkNeedsPaint)
}


func (d *Drawer) Close() {
    if !d.isOpen {
        return
    }
    d.isOpen = false
    d.Rect.Min = d.Rect.Min.Sub(drwSizeChange[d.pos][0])
    d.Rect.Max = d.Rect.Max.Sub(drwSizeChange[d.pos][1])
    d.Mark(MarkNeedsPaint)
}

