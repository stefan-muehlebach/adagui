package binding

import (
    "fmt"
)

// Float ----------------------------------------------------------------------

// Mit Float sehen wir nun die erste kokrete Implementation eines
// Bind-Objektes, welches in diesem Fall einen 64-Bit Fliesskommawert
// enthalten kann. Auch bei diesen Typen wird streng zwischen dem Interface
// (Float, ExternalFloat, etc) und der konkreten Realisierung (boundFloat,
// boundExternalFloat) unterschieden.
type Float interface {
    DataItem
    Get() (float64)
    Set(float64)
}

type boundFloat struct {
    base
    val *float64
}

// Mit NewFloat wird ein neues Bind-Objekt fuer einen float64-Wert erzeugt.
// Der Wert selber ist dabei von aussen nur ueber die Methoden Get und Set
// zugreifbar.
func NewFloat() Float {
    var blank float64 = 0.0
    b := &boundFloat{val: &blank}
    b.Init(b)
    return b
}

func (b *boundFloat) Get() (float64) {
    b.lock.RLock()
    defer b.lock.RUnlock()
    if b.val == nil {
        return 0.0
    }
    return *b.val
}

func (b *boundFloat) Set(val float64) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if *b.val == val {
        return
    }
    *b.val = val
    b.trigger()
}

// ExternalFloat

type ExternalFloat interface {
    Float
    Reload()
}

type boundExternalFloat struct {
    boundFloat
    old float64
}

// Mit BindFloat kann ein Bind-Objekt ueber eine bereits bestehende float64-
// Variable erstellt werden. Dabei muss der Programmierer dafuer sorgen, dass
// Veraenderungen an der Variable mit der Methode Reload nach aussen bekannt
// gemacht werden.
func BindFloat(v *float64) ExternalFloat {
    if v == nil {
        var blank float64 = 0.0
        v = &blank
    }
    b := &boundExternalFloat{}
    b.val = v
    b.old = *v
    b.Init(b)
    return b
}

func (b *boundExternalFloat) Set(val float64) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if b.old == val {
        return
    }
    *b.val = val
    b.old = val
    b.trigger()
}

func (b *boundExternalFloat) Reload() {
    b.Set(*b.val)
}

// String ---------------------------------------------------------------------

type String interface {
    DataItem
    Get() (string)
    Set(string)
}

type boundString struct {
    base
    val *string
}

func NewString() String {
    var blank string = ""
    b := &boundString{val: &blank}
    b.Init(b)
    return b
}

func (b *boundString) Get() (string) {
    b.lock.RLock()
    defer b.lock.RUnlock()
    if b.val == nil {
        return ""
    }
    return *b.val
}

func (b *boundString) Set(val string) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if *b.val == val {
        return
    }
    *b.val = val
    b.trigger()
}

// ExternalString

type ExternalString interface {
    String
    Reload()
}

type boundExternalString struct {
    boundString
    old string
}

func BindString(v *string) ExternalString {
    if v == nil {
        var blank string = ""
        v = &blank
    }
    b := &boundExternalString{}
    b.val = v
    b.old = *v
    b.Init(b)
    return b
}

func (b *boundExternalString) Set(val string) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if b.old == val {
        return
    }
    *b.val = val
    b.old = val
    b.trigger()
}

func (b *boundExternalString) Reload() {
    b.Set(*b.val)
}

// Bool -----------------------------------------------------------------------

type Bool interface {
    DataItem
    Get() (bool)
    Set(bool)
}

type boundBool struct {
    base
    val *bool
}

func NewBool() Bool {
    var blank bool = false
    b := &boundBool{val: &blank}
    b.Init(b)
    return b
}

func (b *boundBool) Get() (bool) {
    b.lock.RLock()
    defer b.lock.RUnlock()
    if b.val == nil {
        return false
    }
    return *b.val
}

func (b *boundBool) Set(val bool) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if *b.val == val {
        return
    }
    *b.val = val
    b.trigger()
}

// ExternalBool

type ExternalBool interface {
    Bool
    Reload()
}

type boundExternalBool struct {
    boundBool
    old bool
}

func BindBool(v *bool) ExternalBool {
    if v == nil {
        var blank bool = false
        v = &blank
    }
    b := &boundExternalBool{}
    b.val =  v
    b.old = *v
    b.Init(b)
    return b
}

func (b *boundExternalBool) Set(val bool) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if b.old == val {
        return
    }
    *b.val = val
    b.old = val
    b.trigger()
}

func (b *boundExternalBool) Reload() {
    b.Set(*b.val)
}

// Int -----------------------------------------------------------------------

type Int interface {
    DataItem
    Get() (int)
    Set(int)
}

type boundInt struct {
    base
    val *int
}

func NewInt() Int {
    var blank int = 0
    b := &boundInt{val: &blank}
    b.Init(b)
    return b
}

func (b *boundInt) Get() (int) {
    b.lock.RLock()
    defer b.lock.RUnlock()
    if b.val == nil {
        return 0
    }
    return *b.val
}

func (b *boundInt) Set(val int) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if *b.val == val {
        return
    }
    *b.val = val
    b.trigger()
}

// ExternalInt

type ExternalInt interface {
    Int
    Reload()
}

type boundExternalInt struct {
    boundInt
    old int
}

func BindInt(v *int) ExternalInt {
    if v == nil {
        var blank int = 0
        v = &blank
    }
    b := &boundExternalInt{}
    b.val =  v
    b.old = *v
    b.Init(b)
    return b
}

func (b *boundExternalInt) Set(val int) {
    b.lock.Lock()
    defer b.lock.Unlock()
    if b.old == val {
        return
    }
    *b.val = val
    b.old = val
    b.trigger()
}

func (b *boundExternalInt) Reload() {
    b.Set(*b.val)
}

//-----------------------------------------------------------------------------

func FloatToStringWithFormat(v Float, format string) (String) {
    if format == "%f" {
        return FloatToString(v)
    }
    s := NewString()
    v.AddCallback(func (data DataItem) {
        val := data.(Float).Get()
        s.Set(fmt.Sprintf(format, val))
    })
    return s
}

func FloatToString(v Float) (String) {
    s := NewString()
    v.AddCallback(func (data DataItem) {
        val := data.(Float).Get()
        s.Set(fmt.Sprintf("%f", val))
    })
    return s
}

